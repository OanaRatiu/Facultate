
/*
 * @(#)Portofolio.java
 *
 * Generated by <a href="http://lci.cs.ubbcluj.ro/ocle/>OCLE 2.0</a>
 * using <a href="http://jakarta.apache.org/velocity/">
 * Velocity Template Engine 1.3rc1</a>
 */
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import ro.ubbcluj.lci.codegen.framework.dt.Real;
import ro.ubbcluj.lci.codegen.framework.ocl.BasicConstraintChecker;
import ro.ubbcluj.lci.codegen.framework.ocl.CollectionUtilities;
import ro.ubbcluj.lci.codegen.framework.ocl.Ocl;
import ro.ubbcluj.lci.codegen.framework.ocl.OclType;

/**
 *
 * @author unascribed
 */
public class Portofolio {

	
	public void add(Holding h) {

		
		class ConstraintChecker {

			
			public void checkPreconditions(Holding h) {

			}
			
			public void checkPostconditions(Holding h) {

				check_postcondition(h);

			}
			
			public void check_postcondition(Holding h) {

				Set setHoldings = Portofolio.this.getHoldings();
				Set setHoldings0 = Portofolio.this.getHoldings();
				Set setIncluding = CollectionUtilities.including(setHoldings0, h);
				boolean bEquals = setHoldings.equals(setIncluding);
				if (!bEquals) {
					System.err.println("postcondition 'postcondition' failed for object "+Portofolio.this);
				}

			}

		}
		ConstraintChecker checker = new ConstraintChecker();
		checker.checkPreconditions(h);
		internal_add(h);
		checker.checkPostconditions(h);

	}
	
	public boolean add(Order o) {

		return false;

	}
	
	public boolean remove(Holding h) {

		return false;

	}
	
	public boolean remove(Order o) {

		return false;

	}
	
	public float loanValue() {

		
		class ConstraintChecker {

			
			float result;
			
			public void checkPreconditions() {

			}
			
			public void checkPostconditions() {

				check_resultUsingReject();
				check_resultUsingSelect();
				check_postcondition();

			}
			
			public void check_resultUsingReject() {

				Set setHoldings = Portofolio.this.getHoldings();
				//evaluate 'reject(security.oclType=Option)':
				Set setReject = CollectionUtilities.newSet();
				final Iterator iter = setHoldings.iterator();
				while (iter.hasNext()) {
					final Holding iter1 = (Holding)iter.next();
					Security securitySecurity = iter1.getSecurity();
					OclType typeOclType = Ocl.type(securitySecurity);
				boolean bEquals0 = typeOclType.equals(Ocl.getType(new Class[]{Option.class}));
					
					if (!bEquals0) CollectionUtilities.add(setReject, iter1);
				}
				//evaluate 'iterate(h:Holding;v:float=0|if(h.security.oclType=Bond)then v+(h.number*security.price*0.9)else v+(h.number*security.price*0.6)endif)':
				//first initialize the accumulator (v):
				
				float v = 0;
				final Iterator iter0 = setReject.iterator();
				while (iter0.hasNext()) {
					final Holding h = (Holding)iter0.next();
					float fIf;
					Security securitySecurity = h.getSecurity();
					OclType typeOclType = Ocl.type(securitySecurity);
				boolean bEquals0 = typeOclType.equals(Ocl.getType(new Class[]{Bond.class}));
					
					if (bEquals0) {
						int nNumber = h.number;
						Security securitySecurity0 = h.getSecurity();
						float fPrice = securitySecurity0.price;
						float fMultiply0 = nNumber * fPrice;
						float fMultiply = fMultiply0 * 0.9f;
						float fPlus = v + fMultiply;
						
						fIf = fPlus;
					}
					else {
						int nNumber = h.number;
						Security securitySecurity0 = h.getSecurity();
						float fPrice = securitySecurity0.price;
						float fMultiply0 = nNumber * fPrice;
						float fMultiply = fMultiply0 * 0.6f;
						float fPlus = v + fMultiply;
						
						fIf = fPlus;
					}
					
					v = fIf;
				}
				float fIterate = v;
				boolean bEquals = result == fIterate;
				if (!bEquals) {
					System.err.println("postcondition 'resultUsingReject' failed for object "+Portofolio.this);
				}

			}
			
			public void check_resultUsingSelect() {

				Set setHoldings = Portofolio.this.getHoldings();
				//evaluate 'select(security.oclType=Bond or security.oclType=Stock)':
				Set setSelect = CollectionUtilities.newSet();
				final Iterator iter = setHoldings.iterator();
				while (iter.hasNext()) {
					final Holding iter1 = (Holding)iter.next();
					Security securitySecurity = iter1.getSecurity();
					OclType typeOclType = Ocl.type(securitySecurity);
				boolean bEquals0 = typeOclType.equals(Ocl.getType(new Class[]{Bond.class}));
					Security securitySecurity0 = iter1.getSecurity();
					OclType typeOclType0 = Ocl.type(securitySecurity0);
				boolean bEquals1 = typeOclType0.equals(Ocl.getType(new Class[]{Stock.class}));
					boolean bOr = bEquals0 || bEquals1;
					
					if (bOr) CollectionUtilities.add(setSelect, iter1);
				}
				//evaluate 'iterate(h:Holding;value:real=0|if(h.security.oclType=Bond)then value+(number*security.price*0.9)else value+(number*security.price*0.6)endif)':
				//first initialize the accumulator (value0):
				
				float value0 = 0;
				final Iterator iter0 = setSelect.iterator();
				while (iter0.hasNext()) {
					final Holding h = (Holding)iter0.next();
					float fIf;
					Security securitySecurity = h.getSecurity();
					OclType typeOclType = Ocl.type(securitySecurity);
				boolean bEquals0 = typeOclType.equals(Ocl.getType(new Class[]{Bond.class}));
					
					if (bEquals0) {
						int nNumber = h.number;
						Security securitySecurity0 = h.getSecurity();
						float fPrice = securitySecurity0.price;
						float fMultiply0 = nNumber * fPrice;
						float fMultiply = fMultiply0 * 0.9f;
						float fPlus = value0 + fMultiply;
						
						fIf = fPlus;
					}
					else {
						int nNumber = h.number;
						Security securitySecurity0 = h.getSecurity();
						float fPrice = securitySecurity0.price;
						float fMultiply0 = nNumber * fPrice;
						float fMultiply = fMultiply0 * 0.6f;
						float fPlus = value0 + fMultiply;
						
						fIf = fPlus;
					}
					
					value0 = fIf;
				}
				float fIterate = value0;
				boolean bEquals = result == fIterate;
				if (!bEquals) {
					System.err.println("postcondition 'resultUsingSelect' failed for object "+Portofolio.this);
				}

			}
			
			public void check_postcondition() {

				Set setHoldings = Portofolio.this.getHoldings();
				//evaluate 'select(security.oclType=Bond or security.oclType=Stock)':
				Set setSelect = CollectionUtilities.newSet();
				final Iterator iter = setHoldings.iterator();
				while (iter.hasNext()) {
					final Holding iter1 = (Holding)iter.next();
					Security securitySecurity = iter1.getSecurity();
					OclType typeOclType = Ocl.type(securitySecurity);
				boolean bEquals0 = typeOclType.equals(Ocl.getType(new Class[]{Bond.class}));
					Security securitySecurity0 = iter1.getSecurity();
					OclType typeOclType0 = Ocl.type(securitySecurity0);
				boolean bEquals1 = typeOclType0.equals(Ocl.getType(new Class[]{Stock.class}));
					boolean bOr = bEquals0 || bEquals1;
					
					if (bOr) CollectionUtilities.add(setSelect, iter1);
				}
				//evaluate 'iterate(h:Holding;value:real=0|if(h.security.oclType=Bond)then value+(number*security.price*0.9)else value+(number*security.price*0.6)endif)':
				//first initialize the accumulator (value0):
				
				float value0 = 0;
				final Iterator iter0 = setSelect.iterator();
				while (iter0.hasNext()) {
					final Holding h = (Holding)iter0.next();
					float fIf;
					Security securitySecurity = h.getSecurity();
					OclType typeOclType = Ocl.type(securitySecurity);
				boolean bEquals0 = typeOclType.equals(Ocl.getType(new Class[]{Bond.class}));
					
					if (bEquals0) {
						int nNumber = h.number;
						Security securitySecurity0 = h.getSecurity();
						float fPrice = securitySecurity0.price;
						float fMultiply0 = nNumber * fPrice;
						float fMultiply = fMultiply0 * 0.9f;
						float fPlus = value0 + fMultiply;
						
						fIf = fPlus;
					}
					else {
						int nNumber = h.number;
						Security securitySecurity0 = h.getSecurity();
						float fPrice = securitySecurity0.price;
						float fMultiply0 = nNumber * fPrice;
						float fMultiply = fMultiply0 * 0.6f;
						float fPlus = value0 + fMultiply;
						
						fIf = fPlus;
					}
					
					value0 = fIf;
				}
				float fIterate = value0;
				boolean bEquals = result == fIterate;
				if (!bEquals) {
					System.err.println("postcondition 'postcondition' failed for object "+Portofolio.this);
				}

			}

		}
		ConstraintChecker checker = new ConstraintChecker();
		checker.checkPreconditions();
		checker.result = internal_loanValue();

		checker.checkPostconditions();
		return checker.result;

	}
	
	public float margin() {

		return 0;

	}
	
	public void create() {

	}
	
	public final Customer getOwner() {

		return owner;
	}
	
	public final void setOwner(Customer arg) {

		if (owner != arg) {
			Customer temp = owner;
			owner = null;//to avoid infinite recursions
			if (temp != null) {
				temp.removePossession(this);
			}
			if (arg != null) {
				owner = arg;
				arg.addPossession(this);
			}
		}

	}
	
	public final Set getOrders() {

		if (orders == null) {
			return java.util.Collections.EMPTY_SET;
		}
		return java.util.Collections.unmodifiableSet(orders);
	}
	
	public final void addOrders(Order arg) {

		if (arg != null) {
			if (orders == null) orders = new LinkedHashSet();
			if (orders.add(arg)) {
				arg.addPortofolio(this);
			}
		}

	}
	
	public final void removeOrders(Order arg) {

		if (orders != null && arg != null) {
			if (orders.remove(arg)) {
				arg.removePortofolio(this);
			}
		}

	}
	
	public final Set getHoldings() {

		if (holdings == null) {
			return java.util.Collections.EMPTY_SET;
		}
		return java.util.Collections.unmodifiableSet(holdings);
	}
	
	public final void addHoldings(Holding arg) {

		if (arg != null) {
			if (holdings == null) holdings = new LinkedHashSet();
			if (holdings.add(arg)) {
				arg.addPortofolio(this);
			}
		}

	}
	
	public final void removeHoldings(Holding arg) {

		if (holdings != null && arg != null) {
			if (holdings.remove(arg)) {
				arg.removePortofolio(this);
			}
		}

	}
	
	public final Cash_Account getCash_position() {

		return cash_position;
	}
	
	public final void setCash_position(Cash_Account arg) {

		if (cash_position != arg) {
			Cash_Account temp = cash_position;
			cash_position = null;//to avoid infinite recursions
			if (temp != null) {
				temp.removePortofolio(this);
			}
			if (arg != null) {
				cash_position = arg;
				arg.addPortofolio(this);
			}
		}

	}
	
	public float priceOfOrders() {

		Set setOrders = Portofolio.this.getOrders();
		//evaluate 'collect(security)':
		List bagCollect = CollectionUtilities.newBag();
		final Iterator iter = setOrders.iterator();
		while (iter.hasNext()) {
			final Order decl = (Order)iter.next();
			Security securitySecurity = decl.getSecurity();
			
			bagCollect.add(securitySecurity);
		}
		bagCollect = CollectionUtilities.flatten(bagCollect);
		
		//evaluate 'collect(price)':
		List bagCollect0 = CollectionUtilities.newBag();
		final Iterator iter0 = bagCollect.iterator();
		while (iter0.hasNext()) {
			final Security decl = (Security)iter0.next();
			float fPrice = decl.price;
			
			bagCollect0.add(Real.toReal(fPrice));
		}
		bagCollect0 = CollectionUtilities.flatten(bagCollect0);
		
		float fSum = CollectionUtilities.sum(bagCollect0);
		return fSum;

	}
	
	public float priceOfHoldings() {

		Set setHoldings = Portofolio.this.getHoldings();
		//evaluate 'collect(security)':
		List bagCollect = CollectionUtilities.newBag();
		final Iterator iter = setHoldings.iterator();
		while (iter.hasNext()) {
			final Holding decl = (Holding)iter.next();
			Security securitySecurity = decl.getSecurity();
			
			bagCollect.add(securitySecurity);
		}
		bagCollect = CollectionUtilities.flatten(bagCollect);
		
		//evaluate 'collect(price)':
		List bagCollect0 = CollectionUtilities.newBag();
		final Iterator iter0 = bagCollect.iterator();
		while (iter0.hasNext()) {
			final Security decl = (Security)iter0.next();
			float fPrice = decl.price;
			
			bagCollect0.add(Real.toReal(fPrice));
		}
		bagCollect0 = CollectionUtilities.flatten(bagCollect0);
		
		float fSum = CollectionUtilities.sum(bagCollect0);
		return fSum;

	}
	
	public float value() {

		float fpriceOfHoldings = Portofolio.this.priceOfHoldings();
		float fpriceOfOrders = Portofolio.this.priceOfOrders();
		float fMinus = fpriceOfHoldings - fpriceOfOrders;
		float temp = fMinus;
		float fIf;
		boolean bGreater = temp > 0;
		
		if (bGreater) {
			
			fIf = temp;
		}
		else {
			
			fIf = 0;
		}
		return fIf;

	}
	
	private void internal_add(Holding h) {

	}
	
	private float internal_loanValue() {

		return 0;

	}
	
	public Portofolio() {

	}
	
	public class ConstraintChecker extends BasicConstraintChecker {

		
		public void checkConstraints() {

			super.checkConstraints();
			check_Portofolio_val();
			check_Portofolio_calcTotalValueOfPortofolio();

		}
		
		public void check_Portofolio_val() {

			float fValue = Portofolio.this.value;
			Set setHoldings = Portofolio.this.getHoldings();
			//evaluate 'iterate(h:Holding;acc:float=0|acc+h.number*h.security.price)':
			//first initialize the accumulator (acc):
			
			float acc = 0;
			final Iterator iter = setHoldings.iterator();
			while (iter.hasNext()) {
				final Holding h = (Holding)iter.next();
				int nNumber = h.number;
				Security securitySecurity = h.getSecurity();
				float fPrice = securitySecurity.price;
				float fMultiply = nNumber * fPrice;
				float fPlus = acc + fMultiply;
				
				acc = fPlus;
			}
			float fIterate = acc;
			boolean bEquals = fValue == fIterate;
			if (!bEquals) {
				System.err.println("invariant 'val' failed for object "+Portofolio.this);
			}

		}
		
		public void check_Portofolio_calcTotalValueOfPortofolio() {

			float fValue = Portofolio.this.value;
			Set setHoldings = Portofolio.this.getHoldings();
			//evaluate 'iterate(h:Holding;result:real=0|result+(h.number*h.security.price))':
			//first initialize the accumulator (result):
			
			float result = 0;
			final Iterator iter = setHoldings.iterator();
			while (iter.hasNext()) {
				final Holding h = (Holding)iter.next();
				int nNumber = h.number;
				Security securitySecurity = h.getSecurity();
				float fPrice = securitySecurity.price;
				float fMultiply = nNumber * fPrice;
				float fPlus = result + fMultiply;
				
				result = fPlus;
			}
			float fIterate = result;
			boolean bEquals = fValue == fIterate;
			if (!bEquals) {
				System.err.println("invariant 'calcTotalValueOfPortofolio' failed for object "+Portofolio.this);
			}

		}

	}
	
	public Customer owner;
	
	public Set orders;
	
	public Set holdings;
	
	public Cash_Account cash_position;
	
	String id;
	
	private float value;

}
