

/*
 * @(#)SaleSystem.java
 *
 * Generated by <a href="http://lci.cs.ubbcluj.ro/ocle/>OCLE 2.0</a>
 * using <a href="http://jakarta.apache.org/velocity/">
 * Velocity Template Engine 1.3rc1</a>
 */
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import ro.ubbcluj.lci.codegen.framework.ocl.CollectionUtilities;
import ro.ubbcluj.lci.codegen.framework.ocl.Pairs;

public class SaleSystem {

	public void handleNewSale(Sale sale) {
		// process sale
		log.add(sale);
	}

	public void handleCreateNewProduct(String bCode, String name, float price) {
		stock.addProduct(new Product(bCode, name, price));
	}

	public void handleUpdateProduct(String bCode, Product product) {
		stock.updateProduct(bCode, product);
	}

	public void handleDeleteProduct(String bCode) {
		stock.deleteProduct(bCode);
	}

	public final Administrator getAdministrator() {

		return administrator;
	}

	public final void setAdministrator(Administrator arg) {

		if (administrator != arg) {
			Administrator temp = administrator;
			administrator = null;// to avoid infinite recursion
			if (temp != null) {
				temp.setJob(null);
			}
			if (arg != null) {
				administrator = arg;
				arg.setJob(this);
			}
		}

	}

	public final Set<SaleAgent> getSaleAgents() {

		if (saleAgents == null) {
			return Collections.emptySet();
		}
		return java.util.Collections.unmodifiableSet(saleAgents);
	}

	public final void addSaleAgents(SaleAgent arg) {

		if (arg != null) {
			if (saleAgents == null) {
				saleAgents = new LinkedHashSet<SaleAgent>();
			}
			if (saleAgents.add(arg)) {
				arg.setJob(this);
			}
		}

	}

	public final void removeSaleAgents(SaleAgent arg) {

		if (saleAgents != null && arg != null) {
			if (saleAgents.remove(arg)) {
				arg.setJob(null);
			}
		}

	}

	@SuppressWarnings("unchecked")
	public final Set<Sale> getLog() {

		if (log == null) {
			return java.util.Collections.EMPTY_SET;
		}
		return java.util.Collections.unmodifiableSet(log);
	}

	public final void addLog(Sale arg) {

		if (arg != null) {
			if (log == null) {
				log = new LinkedHashSet<Sale>();
			}
			log.add(arg);
		}

	}

	public final void removeLog(Sale arg) {

		if (log != null && arg != null) {
			log.remove(arg);
		}

	}

	public final Stock getStock() {

		return stock;
	}

	public final void setStock(Stock arg) {

		stock = arg;
	}


	public SaleSystem(Administrator administrator, Set<SaleAgent> saleAgents,
			Set<Sale> log, Stock stock) {
		super();
		this.administrator = administrator;
		this.saleAgents = saleAgents;
		this.log = log;
		this.stock = stock;
	}

	
	public SaleSystem(Set<Sale> log, Stock stock) {
		super();
		this.log = log;
		this.stock = stock;
	}




	private Administrator administrator;

	private Set<SaleAgent> saleAgents;

	private Set<Sale> log;

	private Stock stock;

	
	
	 public String mostSalesAgent() {

	        Set<?> setSaleAgents = SaleSystem.this.getSaleAgents();
	    //evaluate 'collectNested(a|Tuple{id=a.id,name=a.name,sales=a.sales,valSize=a.sales->size})':
	        List<TupleType1> bagCollectNested = CollectionUtilities.newBag();
	        final Iterator<?> iter = setSaleAgents.iterator();
	        while (iter.hasNext()) {
	            final SaleAgent a = (SaleAgent)iter.next();
	            TupleType1 tuple = new TupleType1();
	            int nId = a.getId();
	            tuple.id = nId;
	            String strName = a.getName();
	            tuple.name = strName;
	            List<?> seqSales = a.getSales();
	            tuple.sales = seqSales;
	            List<?> seqSales0 = a.getSales();
	            int nSize = CollectionUtilities.size(seqSales0);
	            tuple.valSize = nSize;
	            
	            bagCollectNested.add(tuple);
	        }
	        //evaluate 'sortedBy(a|a.valSize)':
	        //use a temporary variable to map the elements in bagCollectNested with the values of the argument expression
	        //These pairs are then sorted by the second element
	        final Pairs sortedPairs = new Pairs();
	        final Iterator<TupleType1> iter0 = bagCollectNested.iterator();
	        while (iter0.hasNext()) {
	            final Object temp = iter0.next();
	            final TupleType1 a = (TupleType1)temp;
	            int nValSize = a.valSize;
	            
	            sortedPairs.addPair(temp, nValSize);
	        }
	        sortedPairs.sort();//sort pairs
	        List<?> seqSortedBy = sortedPairs.asSequence();
	        TupleType1 tupleLast = (TupleType1)CollectionUtilities.last(seqSortedBy);
	        String strName0 = tupleLast.name;
	        return strName0;

	    }
}
