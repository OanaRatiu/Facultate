/*
 * @(#)SaleSystem.java
 *
 * Generated by <a href="http://lci.cs.ubbcluj.ro/ocle/>OCLE 2.0</a>
 * using <a href="http://jakarta.apache.org/velocity/">
 * Velocity Template Engine 1.3rc1</a>
 */
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;

import ro.ubbcluj.lci.codegen.framework.ocl.CollectionUtilities;
import ro.ubbcluj.lci.codegen.framework.ocl.Pairs;

public class SaleSystem {

	public void handleNewSale(Sale sale) {
		// process sale
		log.add(sale);
	}

	public void handleCreateNewProduct(String bCode, String name, float price) {
		stock.addProduct(new Product(bCode, name, price));
	}

	public void handleUpdateProduct(String bCode, Product product) {
		stock.updateProduct(bCode, product);
	}

	public void handleDeleteProduct(String bCode) {
		stock.deleteProduct(bCode);
	}

	public final Administrator getAdministrator() {

		return administrator;
	}

	public final void setAdministrator(Administrator arg) {

		if (administrator != arg) {
			Administrator temp = administrator;
			administrator = null;// to avoid infinite recursion
			if (temp != null) {
				temp.setJob(null);
			}
			if (arg != null) {
				administrator = arg;
				arg.setJob(this);
			}
		}

	}

	public final Set<SaleAgent> getSaleAgents() {

		if (saleAgents == null) {
			return Collections.emptySet();
		}
		return java.util.Collections.unmodifiableSet(saleAgents);
	}

	public final void addSaleAgents(SaleAgent arg) {

		if (arg != null) {
			if (saleAgents == null) {
				saleAgents = new LinkedHashSet<SaleAgent>();
			}
			if (saleAgents.add(arg)) {
				arg.setJob(this);
			}
		}

	}

	public final void removeSaleAgents(SaleAgent arg) {

		if (saleAgents != null && arg != null) {
			if (saleAgents.remove(arg)) {
				arg.setJob(null);
			}
		}

	}

	@SuppressWarnings("unchecked")
	public final Set<Sale> getLog() {

		if (log == null) {
			return java.util.Collections.EMPTY_SET;
		}
		return java.util.Collections.unmodifiableSet(log);
	}

	public final void addLog(Sale arg) {

		if (arg != null) {
			if (log == null) {
				log = new LinkedHashSet<Sale>();
			}
			log.add(arg);
		}

	}

	public final void removeLog(Sale arg) {

		if (log != null && arg != null) {
			log.remove(arg);
		}

	}

	public final Stock getStock() {

		return stock;
	}

	public final void setStock(Stock arg) {

		stock = arg;
	}

	public SaleSystem(Administrator administrator, Set<SaleAgent> saleAgents,
			Set<Sale> log, Stock stock) {
		super();
		this.administrator = administrator;
		this.saleAgents = saleAgents;
		this.log = log;
		this.stock = stock;
	}

	public SaleSystem(Set<Sale> log, Stock stock) {
		super();
		this.log = log;
		this.stock = stock;
	}

	private Administrator administrator;

	private Set<SaleAgent> saleAgents;

	private Set<Sale> log;

	private Stock stock;

	public String mostSalesAgentRefactored() {
		Set<SaleAgent> setSaleAgents = SaleSystem.this.getSaleAgents();
		
		SortedMap<Integer, String> map = new TreeMap<>();
		
		for (SaleAgent saleAgent : setSaleAgents) {
			map.put(saleAgent.sales.size(), saleAgent.getName());
		}
		return map.get(map.lastKey());
	}

	public String mostSalesAgent() {

		Set<SaleAgent> setSaleAgents = SaleSystem.this.getSaleAgents();
		// evaluate
		// 'collectNested(a|Tuple{id=a.id,name=a.name,sales=a.sales,valSize=a.sales->size})':
		List<TupleType1> bagCollectNested = CollectionUtilities.newBag();

		final Iterator<SaleAgent> iter = setSaleAgents.iterator();

		while (iter.hasNext()) {
			final SaleAgent a = (SaleAgent) iter.next();
			TupleType1 tuple = new TupleType1();

			int nId = a.getId();
			tuple.id = nId;
			String strName = a.getName();
			tuple.name = strName;
			List<Sale> seqSales = UtilCast.castList(Sale.class, a.getSales());
			tuple.sales = seqSales;
			List<Sale> seqSales0 = UtilCast.castList(Sale.class, a.getSales());
			int nSize = CollectionUtilities.size(seqSales0);
			tuple.valSize = nSize;

			bagCollectNested.add(tuple);

		}

		// evaluate 'sortedBy(a|a.valSize)':
		// use a temporary variable to map the elements in bagCollectNested with
		// the values of the argument expression
		// These pairs are then sorted by the second element
		final Pairs sortedPairs = new Pairs();
		final Iterator<TupleType1> iter0 = bagCollectNested.iterator();
		while (iter0.hasNext()) {
			final Object temp = iter0.next();
			final TupleType1 a = (TupleType1) temp;
			int nValSize = a.valSize;

			sortedPairs.addPair(temp, nValSize);
		}

		sortedPairs.sort();// sort pairs
		List<TupleType1> seqSortedBy = UtilCast.castList(TupleType1.class,
				sortedPairs.asSequence());
		TupleType1 tupleLast = (TupleType1) CollectionUtilities
				.last(seqSortedBy);
		String strName0 = tupleLast.name;
		return strName0;

	}
}
